<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Thorn的分享小站</title>
  
  <subtitle>听从你心,无问西东</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-03T09:45:44.091Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Thorn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二十三种设计模式（一）单例模式</title>
    <link href="http://yoursite.com/2018/09/03/%E4%BA%8C%E5%8D%81%E4%B8%89%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/09/03/二十三种设计模式（一）单例模式/</id>
    <published>2018-09-03T03:46:15.000Z</published>
    <updated>2018-09-03T09:45:44.091Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式可以说是23中设计模式中最容易的实现和理解的设计模式了，不过单例模式写很容易，但是写好就不容易了，因为单例模式中也隐藏了很多的问题，趁着这次机会，结合网上的一些博客，对单例模式做了一个总结。</p><p>这篇文章对单例模式的大部分问题，都进行了总结描述，并提供了解决方法。</p><p>接下来还会对其他设计模式进行总结，不过我对一些问题，总喜欢尽可能的全面了解，所以每一种设计模式，我都会参考阅读很多文献，尽可能的包括大部分内容，所以更新速度可能较慢。</p><p>对于一些问题，有兴趣深入了解的朋友，我也在文章后面附上了我参考的一些链接，希望我们可以共同进步。</p><a id="more"></a><h3 id="单例模式概念"><a href="#单例模式概念" class="headerlink" title="单例模式概念"></a>单例模式概念</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。</span><br></pre></td></tr></table></figure><h3 id="单例模式的特点"><a href="#单例模式的特点" class="headerlink" title="单例模式的特点"></a>单例模式的特点</h3><ul><li>单例模式只能有一个实例</li><li>单例模式必须自己创建自己的唯一实例</li><li>单例模式必须保证给所有其他对象提供这一实例</li></ul><h3 id="单例模式的应用场景"><a href="#单例模式的应用场景" class="headerlink" title="单例模式的应用场景"></a>单例模式的应用场景</h3><p>需求：在前端创建工具箱窗口，工具箱要么不出现，出现也只出现一个</p><p>遇到问题：每次点击菜单都会重复创建“工具箱”窗口。</p><p>解决方案一：使用if语句，在每次创建对象的时候首先进行判断是否为null，如果为null再创建对象。</p><p>需求：如果在5个地方需要实例出工具箱窗体</p><p>遇到问题：这个小bug需要改动5个地方，并且代码重复，代码利用率低</p><p>解决方案二：利用单例模式，保证一个类只有一个实例，并提供一个访问它的全局访问点。</p><h3 id="单例模式的实现思路"><a href="#单例模式的实现思路" class="headerlink" title="单例模式的实现思路"></a>单例模式的实现思路</h3><p>单例模式要求类返回对象的一个引用(唯一引用)和一个获得该实例的方法(必须是静态方法)</p><p>单例模式的实现需要两步</p><p>先将类的构造方法定义为私有方法,保证在外部无法通过new关键字调用构造方法创建实例对象</p><p>,只能通过类的静态方法获取实例对象。</p><p>在该类的内部定义一个静态方法,当我们调用这个方法时,先判断该类持有的引用是否为空，</p><p>为空则创建该类的实例，将其的引用赋给该静态方法持有的引用,然后返回。</p><h3 id="单例模式的写法"><a href="#单例模式的写法" class="headerlink" title="单例模式的写法"></a>单例模式的写法</h3><h4 id="饿汗式"><a href="#饿汗式" class="headerlink" title="饿汗式"></a>饿汗式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instence = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstence</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instence;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ol><li>这种写法比较简单。</li><li>在类装载的时候就实现了实例化，获取对象速度比较快。</li><li>避免了线程安全问题，</li></ol><p><strong>缺点</strong>：</p><ol><li>这样写效率很低。</li><li>在类装载的时候就完成实例化，没有达到懒加载（Lazy Loading）的效果。</li><li>如果从来没有使用过这个实例，会造成内存浪费。</li></ol><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instence;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstence</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instence == <span class="keyword">null</span>)&#123;</span><br><span class="line">        instence = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instence;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ol><li>这样写相对上一种写法效率有了一些提高。</li><li>这种写法起到了懒加载（Lazy Loading）的效果。</li><li>使用的时候再进行实例化，一定程度避免内存浪费。</li></ol><p><strong>缺点</strong>：这种写法是线程不安全的，在多线程环境下会出现安全问题。</p><p>如果在多线程环境下,一个线程通过了if(instence==null)判断，</p><p>还没有创建实例，但是另一个线程也通过判断进来了，这样就会</p><p>产生多个实例。</p><h4 id="懒汉式变形一（同步代码块-线程安全）"><a href="#懒汉式变形一（同步代码块-线程安全）" class="headerlink" title="懒汉式变形一（同步代码块 线程安全）"></a>懒汉式变形一（同步代码块 线程安全）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instence;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstence</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">        <span class="keyword">if</span>(instence == <span class="keyword">null</span>)&#123;</span><br><span class="line">        instence = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instence;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：这种写法加上了同步代码块，保证了线程安全，避免了上面的写法在多线程情况下出现的问题。</p><p>缺点：这样写会造成每次调用静态方法获取实例对象,都需要进入同步代码块，造成效率低下，因为同步会造成效率的浪费，</p><p>我们要清楚同步是以牺牲效率来换取安全的。</p><h4 id="懒汉式变形二（双重检查-优化）"><a href="#懒汉式变形二（双重检查-优化）" class="headerlink" title="懒汉式变形二（双重检查 优化）"></a>懒汉式变形二（双重检查 优化）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instence;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstence</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instence == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(instence == <span class="keyword">null</span>)&#123;</span><br><span class="line">        instence = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instence;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法是对<strong>变形一</strong>的优化，在外层又加了一层检查，即在同步代码块执行之前先判断实例对象是否存在。</p><p>优点：我们不用再每次调用静态方法获取对象的时候都进行同步，只用进入同步代码块一次就好了。</p><p>大大提高了效率。</p><p>缺点：这样写，会在一定情况下造成线程不安全，由于JVM编译器存在指令重排序，即JVM虚拟机为了提高效率会在其内部对指令的执行顺序在遵循happens-before原则的基础进行调整优化。</p><h5 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h5><p>JMM具备一些先天的有序性,即不需要通过任何手段就可以保证的有序性，通常称为happens-before原则。&lt;&lt;JSR-133：happens-before规则：</p><ul><li><strong>程序顺序规则：</strong> 一个线程中的每个操作，happens-before于该线程中的任意后续操作</li><li><strong>监视器锁规则：</strong>对一个线程的解锁，happens-before于随后对这个线程的加锁</li><li><strong>volatile变量规则：</strong> 对一个volatile域的写，happens-before于后续对这个volatile域的读</li><li><strong>传递性：</strong>如果A happens-before B ,且 B happens-before C, 那么 A happens-before C</li><li><strong>start()规则：</strong> 如果线程A执行操作ThreadB_start()(启动线程B) , 那么A线程的ThreadB_start()happens-before 于B中的任意操作</li><li><strong>join()原则：</strong> 如果A执行ThreadB.join()并且成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li><li><strong>interrupt()原则：</strong> 对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生</li><li><strong>finalize()原则：</strong>一个对象的初始化完成先行发生于它的finalize()方法的开始</li></ul><p>我们创建实例对象的语句中包含三个指令：</p><p>memory =allocate();    //1：分配对象的内存空间 </p><p>ctorInstance(memory);  //2：初始化对象 </p><p>instance =memory;     //3：设置instance指向刚分配的内存地址 </p><p>但是这样的指令顺序并非一成不变的，经过JVM和CPU的优化，其顺序可能会变成：</p><p>memory =allocate();    //1：分配对象的内存空间 </p><p>instance =memory;     //3：设置instance指向刚分配的内存地址 </p><p>ctorInstance(memory);  //2：初始化对象 </p><p>当一个线程执行完1,3,时，instance对象还未完成初始化，但已经不再指向null。此时如果另一个线程抢占到CPU资源，执行  if（instance == null）的结果会是false，从而返回一个没有初始化完成的instance对象。</p><h4 id="懒汉式变形三（volatile-优化）"><a href="#懒汉式变形三（volatile-优化）" class="headerlink" title="懒汉式变形三（volatile 优化）"></a>懒汉式变形三（volatile 优化）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instence;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstence</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instence == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(instence == <span class="keyword">null</span>)&#123;</span><br><span class="line">        instence = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instence;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>volatile关键字有两个功能</strong></p><p>a、保证了不同线程对该变量操作的内存可见性;</p><p>b、 禁止指令重排序</p><p>这样就可以保证在多线程情况下变量访问前后因为指令重排序造成的bug</p><p>这样的话，instance对象的引用要么指向null，要么指向一个初始化完毕的Instance，而不会出现某个中间态，保证了安全。</p><h4 id="静态内部类实现单例"><a href="#静态内部类实现单例" class="headerlink" title="静态内部类实现单例"></a>静态内部类实现单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>从外部无法访问静态内部类LazyHolder，只有当调用Singleton.getInstance方法的时候，才能得到单例对象INSTANCE。</li><li>INSTANCE对象初始化的时机并不是在单例类Singleton被加载的时候，而是在调用getInstance方法，使静态内部类LazyHolder被加载。因此这种实现方式是利用classloader的加载机制来实现懒加载，并保证构建单例的线程安全。</li></ol><h4 id="枚举实现单例模式"><a href="#枚举实现单例模式" class="headerlink" title="枚举实现单例模式"></a>枚举实现单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonEnum &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举实现的单例模式，不但可以防止利用反射强行构建单例对象，而且可以在枚举类对象被反序列化的时候，保证反序列的返回结果是同一对象。</p><p>但是也存在着缺点，它没有实现懒加载，其单例对象是在枚举类被加载的时候进行初始化的。</p><p>不过由于枚举是在jdk1.5以后才诞生的，所以我们在实际开发中很少看到。</p><p>最后，至于懒加载（lazy-loading），考虑到一般情况不存在调用单例类又不需要实例化单例的情况，所以即便不能做到很好的懒加载（lazy-loading），也并不是大问题。换言之，除了枚举这种方案，饿汉模式也在单例设计中广泛的被应用。</p><p>所以单元素的枚举类型已经逐渐成为实现Singleton的最佳方法。</p><p>不过具体如何使用，还是要结合实际开发中的具体情况来进行使用。</p><h3 id="单例模式的问题"><a href="#单例模式的问题" class="headerlink" title="单例模式的问题"></a>单例模式的问题</h3><h4 id="反射问题"><a href="#反射问题" class="headerlink" title="反射问题"></a>反射问题</h4><p>j单例模式大都存在一个的问题，就是无法防止使用反射重复创建对象</p><p>利用反射打破单例步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得构造器</span></span><br><span class="line">Constructor con = Singleton.class.getDeclaredConstructor();</span><br><span class="line"><span class="comment">//设置为可访问</span></span><br><span class="line">con.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//构造两个不同的对象</span></span><br><span class="line">Singleton singleton1 = (Singleton)con.newInstance();</span><br><span class="line">Singleton singleton2 = (Singleton)con.newInstance();</span><br><span class="line"><span class="comment">//验证是否是不同对象</span></span><br><span class="line">System.out.println(singleton1.equals(singleton2));</span><br></pre></td></tr></table></figure><p> 代码可以简单归纳为三个步骤：</p><p>第一步，获得单例类的构造器。</p><p>第二步，把构造器设置为可访问。</p><p>第三步，使用newInstance方法构造对象。</p><p>最后为了确认这两个对象是否真的是不同的对象，我们使用equals方法进行比较。毫无疑问，比较结果是false。</p><p>但是上面写法中的枚举实现就可以解决这个问题，如果使用枚举实现单例，在利用反射创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得构造器</span></span><br><span class="line">Constructor con = SingletonEnum.class.getDeclaredConstructor();</span><br><span class="line"><span class="comment">//设置为可访问</span></span><br><span class="line">con.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//构造两个不同的对象</span></span><br><span class="line">SingletonEnum singleton1 = (SingletonEnum)con.newInstance();</span><br><span class="line">SingletonEnum singleton2 = (SingletonEnum)con.newInstance();</span><br><span class="line"><span class="comment">//验证是否是不同对象</span></span><br><span class="line">System.out.println(singleton1.equals(singleton2));</span><br><span class="line"> </span><br><span class="line">执行获得构造器这一步的时候，抛出了如下异常：</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NoSuchMethodException: com.lj.Singleton.&lt;init&gt;()</span><br><span class="line">at java.lang.Class.getConstructor0(Class.java:<span class="number">3082</span>)</span><br><span class="line">at java.lang.Class.getDeclaredConstructor(Class.java:<span class="number">2178</span>)</span><br><span class="line">at com.lj.Text01.main(Text01.java:<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>JVM会阻止反射获取枚举的私有构造方法，所有使用枚举可以解决反射重复创建单例对象的问题。</p><h4 id="序列化问题"><a href="#序列化问题" class="headerlink" title="序列化问题"></a>序列化问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下面我们先简要地回顾下对象的序列化。一般来说，一个类实现了 Serializable接口，我们就可以把它往内存里写再从内存里读出而&quot;组装&quot;成一个跟原来一模一样的对象。不过当序列化遇到单例时，里边就有了个问题：从内存读出而组装的对象破坏了单例的规则。单例是要求一个JVM中只有一个类对象的，而现在通过反序列，一个新的对象克隆了出来。</span><br></pre></td></tr></table></figure><p>这样就会出现两个实例对象，破坏了单例模式的规则。</p><p>我们该怎么解决那</p><p>第一种方法：通过枚举实现单例模式，因为枚举的具有自由序列化的特性，所以枚举类对象被反序列化的时候，保证反序列的返回结果是同一对象。</p><p>第二种方法：在类中加入readUnshared()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instence;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstence</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instence == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(instence == <span class="keyword">null</span>)&#123;</span><br><span class="line">        instence = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instence;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123; </span><br><span class="line">   <span class="keyword">return</span> instence; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当JVM从内存中反序列化地”组装”一个新对象时，就会自动调用这个 readResolve方法来返回我们指定好的对象了，单例规则也就得到了保证。 </p><p>readResolve方法的调用流程：ObjectInputStream类的readOrdinaryObject方法，在调用完readSerialData（）方法后，就调用了 ObjectStreamClass类的Object invokeReadResolve(Object obj)方法，通过反射调用了我们自己写的readResolve方法。</p><p>简单来说这就是浅拷贝和深拷贝的区别</p><p>从字面上理解的话就是：<br>浅拷贝—拷贝的级别浅。</p><p>深拷贝—拷贝级别更深。</p><p>具体的就是：</p><p>浅拷贝—能复制变量，如果复制对象的话，当前对象内存在这个对象，则只能复制这个对象的地址。</p><p>深拷贝—能复制变量，也能复制当前对象的内部对象。</p><p>没有readResolve方法时，对象流序列化，便是进行深拷贝，克隆出来一个新实例对象，</p><p>存在readResolve方法时，对象流序列化，便是进行浅拷贝，因为此方法提供了一个对象，那么只能复制</p><p>这个实例对象的地址，指向的还是唯一的实例对象。这样便保证了单例规则。</p><p>上面全文是我对单例模式的一些整理，参考了网上的一些博客，大概有这些</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式可以说是23中设计模式中最容易的实现和理解的设计模式了，不过单例模式写很容易，但是写好就不容易了，因为单例模式中也隐藏了很多的问题，趁着这次机会，结合网上的一些博客，对单例模式做了一个总结。&lt;/p&gt;
&lt;p&gt;这篇文章对单例模式的大部分问题，都进行了总结描述，并提供了解决方法。&lt;/p&gt;
&lt;p&gt;接下来还会对其他设计模式进行总结，不过我对一些问题，总喜欢尽可能的全面了解，所以每一种设计模式，我都会参考阅读很多文献，尽可能的包括大部分内容，所以更新速度可能较慢。&lt;/p&gt;
&lt;p&gt;对于一些问题，有兴趣深入了解的朋友，我也在文章后面附上了我参考的一些链接，希望我们可以共同进步。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>mysql操作命令总结</title>
    <link href="http://yoursite.com/2018/09/01/mysql%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/09/01/mysql操作命令总结/</id>
    <published>2018-09-01T10:05:48.000Z</published>
    <updated>2018-09-03T09:26:43.147Z</updated>
    
    <content type="html"><![CDATA[<p>以下是对mysql基本操作命令进行的总结，只是针对单表进行的一些操作，不包括多表操作。</p><a id="more"></a><h4 id="mysql服务命令"><a href="#mysql服务命令" class="headerlink" title="mysql服务命令"></a>mysql服务命令</h4><p>启动mysql服务：net start mysql</p><p>关闭mysql服务：ner stop mysql</p><p><strong>注意：管理员身份才能开关</strong></p><h4 id="mysql连接命令"><a href="#mysql连接命令" class="headerlink" title="mysql连接命令"></a>mysql连接命令</h4><p>mysql连接：mysql  -uroot  -p;</p><p>输入密码：password:xxxxx</p><p>mysql断开连接：quit或exit        (Linxu中也可以ctrl+D)</p><h4 id="mysql基本数据类型"><a href="#mysql基本数据类型" class="headerlink" title="mysql基本数据类型"></a>mysql基本数据类型</h4><p>常用数据类型：</p><ol><li><p>int：整型（4个字节）</p></li><li><p>double：浮点型（8个字节），近似值</p><p>例如double(5,2)表示最多5位，其中必须有2位小数，即最大值为999.99</p></li><li><p>decimal：精确数值数据，最大位数可以是65</p><p>例如decimal(5,2)能够存储具有五位数和两位小数的任何值，因此可以存储范围为-999.99至999.99。</p></li><li><p>char：固定长度字符串类型；    char(10)    ‘aaa       ‘  固定10个字符，不足补空格， 长度0-255</p><p>缺点：浪费空间，优点:查询速度快</p></li><li><p>varchar：可变长度字符串类型； varchar(10)  ‘aaa’     最多存储10个字符</p><p>缺点：查询速度慢，优点：节省空间</p></li><li><p>text：大文本字符串类型；有字符编码，存储比较大的文本数据。</p></li><li><p>blob：Binary  Large Object二进制大对象数据；可以存储图片、音频、视频</p></li><li><p>date：日期类型，格式为：yyyy-MM-dd；</p></li><li><p>time：时间类型，格式为：hh:mm:ss</p></li><li><p>timestamp：时间戳类型 yyyy-MM-dd hh:mm:ss  会自动赋值</p></li><li><p>datetime:日期时间类型 yyyy-MM-dd hh:mm:ss</p></li></ol><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">指定值和范围</th></tr></thead><tbody><tr><td style="text-align:center"><code>char</code></td><td style="text-align:center">String(0~255)</td></tr><tr><td style="text-align:center"><code>varchar</code></td><td style="text-align:center">String(0~255)</td></tr><tr><td style="text-align:center"><code>tinytext</code></td><td style="text-align:center">String(0~255)</td></tr><tr><td style="text-align:center"><code>text</code></td><td style="text-align:center">String(0~65536)</td></tr><tr><td style="text-align:center"><code>blob</code></td><td style="text-align:center">String(0~65536)</td></tr><tr><td style="text-align:center"><code>mediumtext</code></td><td style="text-align:center">String(0~16777215)</td></tr><tr><td style="text-align:center"><code>mediumblob</code></td><td style="text-align:center">String(0~16777215)</td></tr><tr><td style="text-align:center"><code>longblob</code></td><td style="text-align:center">String(0~4294967295)</td></tr><tr><td style="text-align:center"><code>int</code></td><td style="text-align:center">Integer(-214847668~214847667)</td></tr><tr><td style="text-align:center"><code>bigint</code></td><td style="text-align:center">Integer(-9223372036854775808~9223372036854775807)</td></tr><tr><td style="text-align:center"><code>float</code></td><td style="text-align:center">decimal(精确到23位小数)</td></tr><tr><td style="text-align:center"><code>double</code></td><td style="text-align:center">decimal(24~54位小数)</td></tr><tr><td style="text-align:center"><code>decimal</code></td><td style="text-align:center">将<code>double</code>转储为字符串形式</td></tr><tr><td style="text-align:center"><code>date</code></td><td style="text-align:center"><em>YYYY-MM-DD</em></td></tr><tr><td style="text-align:center"><code>datetime</code></td><td style="text-align:center"><em>YYYY-MM-DD HH:MM:SS</em></td></tr><tr><td style="text-align:center"><code>timestamp</code></td><td style="text-align:center"><em>YYYYMMDDHHMMSS</em></td></tr><tr><td style="text-align:center"><code>time</code></td><td style="text-align:center"><em>HH:MM:SS</em></td></tr><tr><td style="text-align:center"><code>enum</code></td><td style="text-align:center">选项值之一</td></tr><tr><td style="text-align:center"><code>set</code></td><td style="text-align:center">选项值子集</td></tr></tbody></table><h4 id="mysql常用约束"><a href="#mysql常用约束" class="headerlink" title="mysql常用约束"></a>mysql常用约束</h4><ul><li>​主键约束：primary key (保证数据唯一性),不能重复，不能为null</li><li>唯一约束：unique [key],不能重复，可以为null</li><li>非空约束：not null</li><li>默认约束：default </li><li>外键约束：foreign key</li><li>自动增长：auto_increment</li></ul><h4 id="mysql数据库操作命令"><a href="#mysql数据库操作命令" class="headerlink" title="mysql数据库操作命令"></a>mysql数据库操作命令</h4><h5 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.show databases; 显示当前mysql中的数据库</span><br><span class="line">2.show <span class="keyword">create</span> databaes 数据库名; 查看数据库定义信息</span><br></pre></td></tr></table></figure><p><strong>系统默认数据库</strong></p><p>information_schema:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">information_schema数据库是MySQL自带的，它提供了访问数据库元数据的方式。</span><br><span class="line">什么是元数据呢？元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。</span><br></pre></td></tr></table></figure><p>mysql:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql：这个是mysql的核心数据库,</span><br><span class="line">主要负责存储数据库的用户、权限设置、关键字等mysql自己需要使用的控制和管理信息，不可以删除。</span><br></pre></td></tr></table></figure><p>performance_schema:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">性能优化的数据库</span><br></pre></td></tr></table></figure><p>test:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个是安装时候创建的一个测试数据库，和它的名字一样，是一个完全的空数据库，没有任何表，可以删除。</span><br></pre></td></tr></table></figure><h5 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.create database 自定义数据库名;（数据库已存在会报错）</span><br><span class="line">2.create database if not exists 数据库名 character <span class="keyword">set</span> gbk;</span><br><span class="line">（先判断数据库存不存在，不存在在创建，并设置数据库编码）</span><br><span class="line">if not exists 不存在则执行后面语句</span><br></pre></td></tr></table></figure><h5 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修改数据库编码为utf8</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> 数据库名 <span class="built_in">character</span> <span class="keyword">set</span> utf8;</span><br></pre></td></tr></table></figure><h5 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> 数据库名;（数据库不存在会报错）</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">exists</span> 数据库名;（先判断数据库存在与否，存在在删除）</span><br><span class="line">if exists 判断数据库是否存在（存在则执行后面语句）</span><br></pre></td></tr></table></figure><h5 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.use  数据库名; 切换数据库</span><br><span class="line">2.select databaes();  查看当前选择的数据库,没有选择数据库，为null;</span><br></pre></td></tr></table></figure><h4 id="mysql数据表操作命令"><a href="#mysql数据表操作命令" class="headerlink" title="mysql数据表操作命令"></a>mysql数据表操作命令</h4><h5 id="查询数据表"><a href="#查询数据表" class="headerlink" title="查询数据表"></a>查询数据表</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;显示当前选择数据库的表</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名;查看表创建细节</span><br></pre></td></tr></table></figure><h5 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">语法： <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 表名(</span><br><span class="line"></span><br><span class="line">                                  字段<span class="number">1</span> 字段类型(长度) 约束,</span><br><span class="line"></span><br><span class="line">                                  字段<span class="number">2</span> 字段类型(长度) 约束,</span><br><span class="line"></span><br><span class="line">                                  ...</span><br><span class="line"></span><br><span class="line">                                  字段n 字段类型(长度) 约束</span><br><span class="line"></span><br><span class="line">                         ) [<span class="keyword">charset</span>=utf8];</span><br><span class="line">例子：<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> student</span><br><span class="line">(</span><br><span class="line">   <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">   age <span class="built_in">INT</span>,</span><br><span class="line">   address <span class="built_in">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">) <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p><strong>注意：数据库名、表名、字段名可以使用反勾号` 括住，也可以不括。如果SQL关键字一般要括住。</strong></p><h5 id="修改数据表"><a href="#修改数据表" class="headerlink" title="修改数据表"></a>修改数据表</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.给当前表增加一列（添加一个字段）</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 类型(长度) 约束;</span><br><span class="line">2.修改当前表字段类型长度</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">modify</span> 字段名 新的字段类型(新的长度);</span><br><span class="line">3.删除当前表的一列</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 列名;</span><br><span class="line">4.修改表的字符集为gbk</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="built_in">character</span> <span class="keyword">set</span> gbk;</span><br><span class="line">5.修改列名</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">change</span> 列名 新的列名 字段类型（长度）;</span><br><span class="line">注意:列名即字段名</span><br></pre></td></tr></table></figure><h5 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">if</span> <span class="keyword">exists</span> 表名; 先判断在删除</span><br></pre></td></tr></table></figure><h5 id="其他操作-1"><a href="#其他操作-1" class="headerlink" title="其他操作"></a>其他操作</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">desc 表名; 查看表结构或字段信息</span><br><span class="line"><span class="keyword">rename</span> <span class="keyword">table</span> 表名 <span class="keyword">to</span> 新表名; 修改表名</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名; 查看表的创建细节</span><br></pre></td></tr></table></figure><h4 id="mysql数据操作命令"><a href="#mysql数据操作命令" class="headerlink" title="mysql数据操作命令"></a>mysql数据操作命令</h4><h5 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h5><p><strong>​查询语句书写顺序：select  列 from 表 【where- group by- having- order by-limit】</strong></p><p><strong>​查询语句执行顺序：from 表 where -group by -having - select - order by-limit</strong>        </p><h6 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from 表名; 查询所有列，*表示所有列</span><br><span class="line"><span class="keyword">select</span> 列名<span class="number">1</span>,列名<span class="number">2</span>,... <span class="keyword">from</span> 表名; 查询指定列</span><br></pre></td></tr></table></figure><h6 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h6><p>条件查询就是在查询时给出WHERE子句，在WHERE子句中可以使用如下运算符及关键字：</p><p><strong>比较运算符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.=、!=、&lt;&gt;、&lt;、&lt;=、&gt;、&gt;=；</span><br><span class="line">2.BETWEEN…AND；</span><br><span class="line">3.IN(set)；</span><br><span class="line">4.IS NULL；</span><br></pre></td></tr></table></figure><p><strong>关系运算符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.AND </span><br><span class="line">2.OR</span><br><span class="line">3.NOT</span><br></pre></td></tr></table></figure><p>注意：AND运算符优先级高于OR,如果需要先执行OR需要添加括号（）改变。</p><p><strong>算数运算符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+  -  *  /  %</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#查询学生表性别为女，而且年龄大于50的人</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> gender=<span class="string">'female'</span> <span class="keyword">AND</span> age&gt;<span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">#查询查询学号为S_1001，或者姓名为liSi的记录</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> <span class="keyword">sid</span>=<span class="string">'S_1001'</span> <span class="keyword">OR</span> sname=<span class="string">'liSi'</span>;</span><br><span class="line"></span><br><span class="line">#查询学号为S1001，S1002，S_1003的记录</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> <span class="keyword">sid</span> <span class="keyword">IN</span> (<span class="string">'S_1001'</span>,<span class="string">'S_1002'</span>,<span class="string">'S_1003'</span>);</span><br><span class="line"></span><br><span class="line">#查询学号不是S1001，S1002，S_1003的记录</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span>  <span class="keyword">sid</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">'S_1001'</span>,<span class="string">'S_1002'</span>,<span class="string">'S_1003'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span>  <span class="keyword">NOT</span> <span class="keyword">sid</span>  <span class="keyword">IN</span> (<span class="string">'S_1001'</span>,<span class="string">'S_1002'</span>,<span class="string">'S_1003'</span>);</span><br><span class="line"></span><br><span class="line">#查询年龄为null的记录</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">#查询年龄在20到40之间的学生记录</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> age <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">40</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> age&gt;<span class="number">20</span> <span class="keyword">AND</span> age&lt;<span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">#查询性别非男的学生记录</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> gender!=<span class="string">'male'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> <span class="keyword">NOT</span> gender=<span class="string">'male'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> gender&lt;&gt;<span class="string">'male'</span>;</span><br><span class="line"></span><br><span class="line">#查询姓名不为null的学生记录</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> <span class="keyword">NOT</span> sname <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> sname <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h6 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h6><p>模糊查询需要使用关键字like和通配符：</p><p>_任意一个</p><p>%任意0到n个字符</p><p>例子</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#查询姓名由3个字符构成的学生记录</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> sname <span class="keyword">LIKE</span> <span class="string">'___'</span>;</span><br><span class="line"></span><br><span class="line">#查询姓名由5个字符构成，并且第5个字符为“i”的学生记录</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> sname <span class="keyword">LIKE</span> <span class="string">'____i'</span>;</span><br><span class="line"></span><br><span class="line">#查询姓名以“z”开头的学生记录</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> sname <span class="keyword">LIKE</span> <span class="string">'z%'</span>;</span><br><span class="line"></span><br><span class="line">#查询姓名中第2个字符为“i”的学生记录</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> sname <span class="keyword">LIKE</span> <span class="string">'_i%'</span>;</span><br><span class="line"></span><br><span class="line">#查询姓名中包含“a”字符的学生记录</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> sname <span class="keyword">LIKE</span> <span class="string">'%a%'</span>;</span><br></pre></td></tr></table></figure><h6 id="字段控制查询"><a href="#字段控制查询" class="headerlink" title="字段控制查询"></a>字段控制查询</h6><ol><li><p>去除重复记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用distinct关键字</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 列名<span class="number">1</span>,列名<span class="number">2</span>,... <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure></li><li><p>合并数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1)数值类型数据直接进行加法运算</span><br><span class="line"><span class="keyword">select</span> *,数值列名+数值列名 <span class="keyword">from</span> 表名;</span><br><span class="line">(2)字符串类型合并不能直接进行加运算，需要使用concat(列名,'____',列名);</span><br><span class="line"><span class="keyword">select</span> *,<span class="keyword">CONCAT</span>(列名,<span class="string">'-'</span>,列名) <span class="keyword">from</span> 表名;</span><br><span class="line">(3)有的列记录包含很多NULL值，因为任何东西与NULL相加结果还是NULL，所以结算结果可能会出现NULL。</span><br><span class="line">可以使用IFNULL函数将NULL值转换为0</span><br><span class="line"><span class="keyword">select</span> *,列名+<span class="keyword">IFNULL</span>(列名,<span class="number">0</span>) <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure></li><li><p>给列名添加别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用AS关键字</span><br><span class="line"><span class="keyword">select</span> *,<span class="keyword">CONCAT</span>(列名,<span class="string">'-'</span>,表名) <span class="keyword">as</span> 别名 <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><p>注意：AS关键字可以省略</p></li></ol><h6 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用ORDER BY关键字，desc表示降序，asc表示升序（默认升序）</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表名 <span class="keyword">Order</span> <span class="keyword">by</span> 列名<span class="number">1</span> <span class="keyword">DESC</span>,列名<span class="number">2</span> <span class="keyword">ASC</span>; 先按列名1数据进行降序排序，相同在按列名2数据升序排序</span><br></pre></td></tr></table></figure><h6 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h6><p>聚合函数是用来做纵向运算的函数：</p><ul><li>COUNT()：统计指定列不为NULL的记录行数；</li><li>MAX()：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；</li><li>MIN()：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；</li><li>SUM()：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0；</li><li>AVG()：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0；</li></ul><h6 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h6><p>分组查询时需要使用GROUP BY  子句</p><p>HAVING子句可以对分组后的数据进行过滤</p><p>注：凡是和聚合函数同时出现的列名，则一定要写在group by 之后</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查询每个部门的部门编号和每个部门的工资和：</span><br><span class="line"><span class="keyword">SELECT</span> deptno,<span class="keyword">SUM</span>(sal) <span class="keyword">FROM</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno;</span><br><span class="line"></span><br><span class="line">#查询每个部门的部门编号以及每个部门工资大于1500的人数</span><br><span class="line"><span class="keyword">SELECT</span> deptno,<span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> sal&gt;<span class="number">1500</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno;</span><br><span class="line"></span><br><span class="line">#查询工资总和大于9000的部门编号以及工资和：</span><br><span class="line"><span class="keyword">SELECT</span> deptno,<span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno <span class="keyword">HAVING</span> <span class="keyword">SUM</span>(sal)&gt;<span class="number">1500</span>;</span><br></pre></td></tr></table></figure><p>注：having与where的区别:</p><ol><li>having是在分组后对数据进行过滤,where是在分组前对数据进行过滤             </li><li>having后面可以使用分组函数(统计函数)</li><li>where后面不可以使用分组函数。<ol start="4"><li>where是对分组前记录的条件，如果某行记录没有满足WHERE子句的条件，那么这行记录不会参加分组；而    having是对分组后数据的约束。</li></ol></li></ol><h6 id="LIMIT限制（分页查询）"><a href="#LIMIT限制（分页查询）" class="headerlink" title="LIMIT限制（分页查询）"></a>LIMIT限制（分页查询）</h6><p>LIMIT用来限定查询结果的起始行，以及总行数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查询前5行数据</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">5</span>;</span><br><span class="line">#查询5到10行数据</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">LIMIT</span> <span class="number">5</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>注意，起始行从0开始，即第一行开始！</p><p>分页查询：</p><p>如果一页记录为10条，希望查看第3页记录应该怎么查呢？</p><p>l  第一页记录起始行为0，一共查询10行;</p><p>l  第二页记录起始行为10，一共查询10行;</p><p>l  第三页记录起始行为20，一共查询10行;</p><h5 id="增加数据"><a href="#增加数据" class="headerlink" title="增加数据"></a>增加数据</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 (列名<span class="number">1</span>,列名<span class="number">2</span>,...) <span class="keyword">values</span>(列值<span class="number">1</span>,列值<span class="number">2</span>,,...);</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>列名与列值的类型、个数、顺序要一一对应。</li><li>可以把列名当做java中的形参，把列值当做实参。</li><li>参数不要超出列定义的长度。</li><li>如果插入空值，请使用null</li><li>插入的日期和字符一样，都使用单引号括起来。</li></ul><h5 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 列名<span class="number">1</span>=列值<span class="number">1</span>,列名<span class="number">2</span>=列值<span class="number">2</span>,...where 列名=列值;</span><br><span class="line">where后面是修改条件（可选操作）;</span><br></pre></td></tr></table></figure><h5 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.delete from 表名; 删除表中所有数据</span><br><span class="line">2.delete from 表名 where 列名=列值; 删除满足where后面条件的数据</span><br><span class="line">3.truncate table emp;使用<span class="keyword">truncate</span>删除表中记录。(先把表删除，然后再创建空表)</span><br></pre></td></tr></table></figure><ul><li>DELETE 删除表中的数据，表结构还在;删除后的数据使用日志可以找回。</li><li>TRUNCATE 删除是把表直接DROP掉，然后再创建一个同样的新表。</li><li>TRUNCATE 删除的数据不能找回。执行速度比DELETE快。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下是对mysql基本操作命令进行的总结，只是针对单表进行的一些操作，不包括多表操作。&lt;/p&gt;
    
    </summary>
    
      <category term="命令" scheme="http://yoursite.com/categories/%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis简介</title>
    <link href="http://yoursite.com/2018/08/31/Mybatis%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2018/08/31/Mybatis简介/</id>
    <published>2018-08-31T11:40:06.000Z</published>
    <updated>2018-08-31T12:41:23.406Z</updated>
    
    <content type="html"><![CDATA[<p>​    MyBatis是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架，MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。</p><p>​    MyBatis可以对配置和原生Map使用简单的XML或注解，将接口和Java的POJOs(Plain Old Java Objects,普通的Java对象)映射成数据库中的记录。</p><a id="more"></a><h2 id="框架概念"><a href="#框架概念" class="headerlink" title="框架概念"></a>框架概念</h2><p>百度百科：框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种定义认为，框架是可被应用开发者定制的应用骨架。<br>对于程序员来说，框架是一套资源，一套解决某一类问题所使用的资源。这套资源中包含：Jar包、文档、源码、示例等内容，或其中部分内容。</p><p>##MyBatis框架介绍</p><p>MyBatis框架的前身是Apache的一个项目，名称为iBaits。2010年，该项目迁移到了Google，更名为MyBatis。2013年，项目又交由GitHub托管。</p><p>我们要下载这个框架从GitHub官网下载    <a href="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3/releases</a></p><p>mybatis-3.4.2.jar  MyBatis的核心Jar包<br>lib                MyBatis核心Jar包所依赖的Jar包<br>mybatis-3.4.2.pdf  MyBatis官方帮助文档</p><h2 id="MyBatis框架的作用"><a href="#MyBatis框架的作用" class="headerlink" title="MyBatis框架的作用"></a>MyBatis框架的作用</h2><p> MyBatis在三层架构中处于Dao层，用于访问数据库。其作用类似于JDBC。</p><h2 id="MyBatis系统架构图"><a href="#MyBatis系统架构图" class="headerlink" title="MyBatis系统架构图"></a>MyBatis系统架构图</h2><p><img src="/img/mybatis结构图.png" alt="mybatis结构图"></p><h2 id="Mybatis框架运行原理"><a href="#Mybatis框架运行原理" class="headerlink" title="Mybatis框架运行原理"></a>Mybatis框架运行原理</h2><pre><code>API：Application Programming Interface，应用程序接口ORM：Object Ralationship Mapping，对象关系映射MyBatis是一种ORM框架，是半自动ORM。MyBatis底层封装了JDBC，Hibernate也是一种ORM框架，是全自动ORM。</code></pre><h2 id="第一个Mybatis程序"><a href="#第一个Mybatis程序" class="headerlink" title="第一个Mybatis程序"></a>第一个Mybatis程序</h2><p>功能：将一个学生信息写入DB</p><h3 id="导入Jar包"><a href="#导入Jar包" class="headerlink" title="导入Jar包"></a>导入Jar包</h3><p>Mybatis的jar包（mybatis核心jai包和mybatis所依赖的jar包lib文件夹下的）</p><p>mysql驱动的jar包</p><p><img src="/img/mybatis所需jar包.png" alt="mybatis所需jar包"></p><h3 id="定义一个Stduent类"><a href="#定义一个Stduent类" class="headerlink" title="定义一个Stduent类"></a>定义一个Stduent类</h3><p>id，name，age，score    </p><pre><code>* 主键id要定义为包装类型，不要定义为基本数据类型，例如，不要定义为int，而要定义为Integer* 若显式地给出了带参构造器，则要显式地给出无参构造器。    -- 若当前实体类有可能作父类，那么要创建子类对象时，JVM会调用其父类的无参构造器    -- 若使用了Spring框架，那么要求由Spring容器所管理的类，必须要有无参构造器</code></pre><h3 id="创建DB表"><a href="#创建DB表" class="headerlink" title="创建DB表"></a>创建DB表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表名：student</span><br><span class="line">字段：id,name,age,score</span><br></pre></td></tr></table></figure><h3 id="定义Dao接口IStudentDao"><a href="#定义Dao接口IStudentDao" class="headerlink" title="定义Dao接口IStudentDao"></a>定义Dao接口IStudentDao</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IStudentDao &#123;</span><br><span class="line">void insertStudent(Student student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义映射文件"><a href="#定义映射文件" class="headerlink" title="定义映射文件"></a>定义映射文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* 是一个XML文件，文件名随意，我们这里叫mapper.xml。</span><br><span class="line">* 该文件定义到Dao接口所在包。</span><br><span class="line">* 约束文件为mybatis-3.4.2.jar ! /org/apache/ibatis/builder/xml/mybatis-3-mapper.dtd</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper&gt;</span><br><span class="line">&lt;insert id=&quot;insertStu&quot; parameterType=&quot;com.abc.beans.Student&quot;&gt;</span><br><span class="line">insert into student(name,age,score) values(#&#123;name&#125;, #&#123;age&#125;, #&#123;score&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><h3 id="定义主配置文件"><a href="#定义主配置文件" class="headerlink" title="定义主配置文件"></a>定义主配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* 是一个XML文件，文件名随意，我们这里叫mybatis.xml</span><br><span class="line">* 定义在src根下</span><br><span class="line">* 约束文件为mybatis-3.4.2.jar ! /org/apache/ibatis/builder/xml/mybatis-3-config.dtd</span><br><span class="line">标签介绍</span><br><span class="line">&lt;transactionManager type=&quot;JDBC&quot; /&gt;</span><br><span class="line">该标签用于指定事务管理器。type的取值有两个：</span><br><span class="line">JDBC：使用JDBC事务管理器</span><br><span class="line">MANAGED：使用第三方事务管理器，例如使用Spring的事务管理器</span><br><span class="line">&lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">该标签用于指定数据源类型。type的取值有三个：</span><br><span class="line">POOLED：使用连接池技术（默认使用的是Mybatis内置连接池）</span><br><span class="line">UNPOOLED：不使用连接池技术</span><br><span class="line">JNDI：Java Naming-Directory Interface，Java命名与目录接口，这是一个容器。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    MyBatis是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架，MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。&lt;/p&gt;
&lt;p&gt;​    MyBatis可以对配置和原生Map使用简单的XML或注解，将接口和Java的POJOs(Plain Old Java Objects,普通的Java对象)映射成数据库中的记录。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM框架" scheme="http://yoursite.com/categories/SSM%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Mybits" scheme="http://yoursite.com/tags/Mybits/"/>
    
  </entry>
  
  <entry>
    <title>心之所向，素履以往</title>
    <link href="http://yoursite.com/2018/08/30/Thorn/"/>
    <id>http://yoursite.com/2018/08/30/Thorn/</id>
    <published>2018-08-30T04:05:56.829Z</published>
    <updated>2018-08-31T05:31:26.682Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/Thorn.jpg"></p><p>人这一生，最幸运的事情便是努力就能得到回报，若是遇到一二，定要尽力抓住。</p><a id="more"></a><p>1.与其驻足，叹咫尺即天涯，不如上路，笑看天涯亦咫尺。</p><p>2.生活多么无趣，但一则则无趣的生活编织在一起，才构成了生命的繁华。</p><p>3.有很多人，你原以为可以忘记。其实没有。他们一直在你心底的一个角落。直到你的生命尽头。在尽头你会怀念每一个角落里的黑暗之中的光，因为他们组成你的记忆与感情。但是你已经不能拥抱他们。只能在最后明白，路途是一个念念不忘的失去的过程。</p><p>4.我们在电影里看着别人替我们过着梦里的人生，看着他们替我们爱，替我们死，动容之时流下眼泪——擦干之后，那不过是灰飞烟灭的幻象，生活仍然一无所有。</p><p>5.我自倾杯，君且随意 ：最深情的话莫过于此了。</p><p>6.但愿你的旅途漫长，但愿你拥抱的人正泪流不止。但愿你付出的爱，有着某种恰到好处的形状，恰能完好地镶嵌在她的灵魂空缺处，毫厘不差。但愿你心底关怀，杯满四溢，又正在被另一个孤独的灵魂渴望着。</p><p>7.但愿你记得，在你痛哭失声的时刻，曾有人以肩窝盛满你的泪。</p><p>8.路是时光的血脉，通向生命不可知的隘口。</p><p>9.我想去相信一个人，非常想。可是每个人在这个世界上忙着生，忙着死，所有人都是如此窘迫的姿态。令我不忍心再向别人索求关怀。如果我们想不对人或事失望，惟一的方法就是不要对它给予任何希望。这不是绝望，这是生存下去的惟一途径，亦是获取幸福感的前提。</p><p>10.我想，沉默是成长的标志，而成熟的标志，就是如何去沉默。我不能说我们生如夏花，活得完美而睿智，死如秋叶亦离我们非常遥远，当下最真实的，不过是一种宽宏和原谅，对自身、他人，以及这个失望和希望并存的世界。</p><p>11.在这个吵得人分不清东南西北得世界里，我们手里所持有的干干净净的初衷，不多了。握好了，别丢了。明天还要赶很远的路。</p><p>12.隐忍平凡的外壳下，要像果实般有着汁甜水蜜的肉瓤，以及一颗坚硬闪亮的内核。</p><p>13.心之所向，素履以往。生如逆旅， 一苇以航。</p><p>14.做学生的时候，身是不自由的，但心却很自由，有多远梦多远。而今，身是自由的，但心已经无法自由。有多少梦，就有多远。</p><p>15.一段感情若势如破竹，最后也往往兵败如山倒。但也曾算是，像把每一天当成是最后一天来珍惜生命那般，把眼前人当成是最后一个人来珍惜感情。奈何世事无常，人无常，爱无常。花辞树，以叶为美。叶落尽，以枝为姿。枝若朽，以根为雕。感情若如四季，我愿如良木。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/Thorn.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;人这一生，最幸运的事情便是努力就能得到回报，若是遇到一二，定要尽力抓住。&lt;/p&gt;
    
    </summary>
    
      <category term="美文" scheme="http://yoursite.com/categories/%E7%BE%8E%E6%96%87/"/>
    
    
      <category term="文章" scheme="http://yoursite.com/tags/%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
</feed>
